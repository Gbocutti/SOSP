<!DOCTYPE html>
<html>
<head>
    <title>Mapa OpenStreetMap com Filtro de STATUS, NOME, OBSERVAÇÃO e REMESSA</title>
    <!-- Importar o CSS do Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <!-- Importar o JavaScript do Leaflet -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <!-- Importar a biblioteca PapaParse para processamento do CSV -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <style>
        /* Define a altura do mapa */
        #map {
            height: 100%;
            margin: 0;
        }
        .leaflet-control-layers {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        .leaflet-control-layers label {
            display: block;
            margin: 5px 0;
        }
        .leaflet-control-layers input {
            margin-right: 5px;
        }
        .filter-toggle-button, .legend-toggle-button, .draw-toggle-button {
            cursor: pointer;
            margin-bottom: 2px;
            padding: 2px;
            background-color: white;
            font-size: 20px;
            color: black;
            border: none;
            border-radius: 3px;
            text-align: center;
            transition: background-color 0.3s ease;
        }
        .filter-toggle-button:hover, .legend-toggle-button:hover, .draw-toggle-button:hover {
            background-color: #0056b3;
            color: white;
        }
        .filter-content, .legend-content, .draw-controls {
            display: none;
            margin-top: 5px;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            display: none;
        }
        .loading-overlay.active {
            display: flex;
        }
        .loading-text {
            font-size: 18px;
            color: #007BFF;
        }
        #password-form {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
            z-index: 10000;
        }
        #password-form input {
            margin-bottom: 10px;
        }
        #password-form button {
            cursor: pointer;
        }
        #password-form button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        #coordinate-panel {
            position: fixed;
            bottom: 3px;
            left: 50px;
            background: white;
            padding: 1px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 20%;
            z-index: 1000;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
        }
        #coordinates-output {
            width: 100%;
            height: 30px;
            resize: none;
        }
        /* Estilo para o controle de pesquisa */
        .search-control {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        .search-control input {
            padding: 5px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 100%;
            box-sizing: border-box;
        }
        .search-control button {
            padding: 5px 10px;
            background-color: white;
            color: black;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 1px;
        }
        .search-control button:hover {
            background-color: #0056b3;
        }
        /* Estilo para os campos de data */
        .date-filter {
            margin-top: 10px;
        }
        .date-filter label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .date-filter input {
            width: 100%;
            padding: 5px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        /* Estilo para a legenda */
        .legend-control {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
            max-width: 200px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
        }
        .legend-color {
            width: 20px;
            height: 10px;
            margin-right: 5px;
            display: inline-block;
        }
        /* Estilo para o ponto de snap */
        .snap-point {
            background-color: #ff0000;
            width: 12px;
            height: 12px;
            border-radius: 6px;
            border: 2px solid white;
            position: absolute;
            pointer-events: none;
            z-index: 1000;
        }
        .draw-snap-control {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        /* Alteração do cursor para padrão (setinha) */
        .leaflet-container {
            cursor: default;
        }
        /* Estilo para o botão de desenho quando ativo */
        .drawing-active {
            background-color: #0056b3 !important;
            color: white !important;
        }
    </style>
</head>
<body>

    <!-- Formulário de senha -->
    <div id="password-form">
        <label for="password">Senha:</label>
        <input type="password" id="password" placeholder="Digite a senha" disabled>
        <button id="password-button" onclick="checkPassword()" disabled>Acessar</button>
        <p id="error-message" style="color: red; display: none;">Senha incorreta!</p>
        <p id="loading-message" style="color: blue; display: none;">Carregando senhas válidas, por favor aguarde...</p>
    </div>

    <!-- Div para o mapa -->
    <div id="map" style="display: none;"></div>

    <!-- Overlay de carregamento -->
    <div class="loading-overlay" id="loading-overlay">
        <span class="loading-text">Carregando dados, por favor aguarde...</span>
    </div>

    <!-- Painel de coordenadas -->
    <div id="coordinate-panel">
        <textarea id="coordinates-output" readonly></textarea>
        <button onclick="copyCoordinates()">Copiar</button>
    </div>

    <!-- Controle de pesquisa com filtros para NOME, OBSERVAÇÃO e REMESSA -->
    <div class="search-control" id="search-control" style="display:none;">
        <button id="toggle-extra-search" class="filter-toggle-button" title="Pesquisar">🔍</button>
        <div id="extra-search" class="filter-content">
            <input type="text" id="search-input" placeholder="Pesquisar por nome...">
            <input type="text" id="observacao-input" placeholder="Pesquisar por observação...">
            <input type="text" id="remessa-input" placeholder="Pesquisar por remessa...">
            <div class="date-filter">
                <label for="start-date">Data Inicial:</label>
                <input type="date" id="start-date">
                <label for="end-date">Data Final:</label>
                <input type="date" id="end-date">
            </div>
            <button id="search-button">Pesquisar</button>
            <button id="clear-search" style="margin-left: 5px;">Limpar</button>
        </div>
    </div>

    <script>
        // URL do CSV com as senhas
        const passwordsCsvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTERpcQ5NONP3R8TGHTbZ04Ckq9Bj31BCQv4SH1eXs_q1v9z-nocOi2jOJEvgE0gVBJ38rxM6KLFRNH/pub?gid=1310394031&single=true&output=csv";
        let validPasswords = [];

        // Mostrar mensagem de carregamento e desabilitar campos
        document.getElementById('loading-message').style.display = 'block';
        document.getElementById('password').disabled = true;
        document.getElementById('password-button').disabled = true;

        // Carregar as senhas válidas do CSV
        function loadValidPasswords() {
            document.getElementById('loading-overlay').classList.add('active');
            Papa.parse(passwordsCsvUrl, {
                download: true,
                header: true,
                complete: function(results) {
                    document.getElementById('loading-overlay').classList.remove('active');
                    if (results.data && results.data.length > 0) {
                        // Extrai todas as senhas não vazias da coluna SENHA
                        validPasswords = results.data
                            .map(row => row.SENHA)
                            .filter(password => password && password.trim() !== '');
                        console.log("Senhas válidas carregadas:", validPasswords);
                        
                        // Habilitar campos de senha agora que os dados foram carregados
                        document.getElementById('password').disabled = false;
                        document.getElementById('password-button').disabled = false;
                        document.getElementById('loading-message').style.display = 'none';
                    } else {
                        console.error("Nenhuma senha encontrada no arquivo CSV");
                        document.getElementById('error-message').textContent = "Erro ao carregar senhas válidas!";
                        document.getElementById('error-message').style.display = 'block';
                        document.getElementById('loading-message').style.display = 'none';
                    }
                },
                error: function(error) {
                    document.getElementById('loading-overlay').classList.remove('active');
                    console.error("Erro ao carregar senhas:", error);
                    document.getElementById('error-message').textContent = "Erro ao carregar senhas válidas!";
                    document.getElementById('error-message').style.display = 'block';
                    document.getElementById('loading-message').style.display = 'none';
                }
            });
        }

        // Carregar as senhas quando a página é carregada
        window.onload = loadValidPasswords;

        // Função para verificar a senha
        function checkPassword() {
            const password = document.getElementById('password').value;
            if (validPasswords.includes(password)) {
                document.getElementById('password-form').style.display = 'none';
                document.getElementById('map').style.display = 'block';
                document.getElementById('search-control').style.display = 'block';
                initializeMap();
            } else {
                document.getElementById('error-message').style.display = 'block';
            }
        }

        // Função para converter data no formato DD/MM/YYYY para objeto Date
        function parseDate(dateString) {
            if (!dateString || dateString.trim() === "") return null;
            
            // Remove espaços em branco
            dateString = dateString.trim();
            
            // Tenta converter de DD/MM/YYYY
            const parts = dateString.split('/');
            if (parts.length === 3) {
                // Verifica se os componentes são números válidos
                const day = parseInt(parts[0]), month = parseInt(parts[1]), year = parseInt(parts[2]);
                if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
                    // Cria a data no formato MM/DD/YYYY (que o Date do JavaScript espera)
                    return new Date(year, month - 1, day);
                }
            }
            
            // Tenta converter de YYYY-MM-DD (formato date input)
            if (dateString.match(/^\d{4}-\d{2}-\d{2}$/)) {
                return new Date(dateString);
            }
            
            // Tenta converter de qualquer outro formato que o Date possa entender
            const parsedDate = new Date(dateString);
            return isNaN(parsedDate.getTime()) ? null : parsedDate;
        }

        // Função para adicionar o controle de legenda
        function addLegendControl(map) {
            var legendControl = L.control({position: 'topright'});
            
            legendControl.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'legend-control');
                
                var toggleButton = L.DomUtil.create('button', 'legend-toggle-button', div);
                toggleButton.innerText = "🎨";
                toggleButton.title = "Legenda de Cores";
                
                var legendContent = L.DomUtil.create('div', 'legend-content', div);
                
                // Conteúdo da legenda
                legendContent.innerHTML = 
                    <strong>Legenda de Status:</strong><br>
                    <div class="legend-item"><span class="legend-color" style="background-color: green;"></span>EXECUTADA</div>
                    <div class="legend-item"><span class="legend-color" style="background-color: red;"></span>AGUARDANDO</div>
                    <div class="legend-item"><span class="legend-color" style="background-color: blue;"></span>FUTURO</div>
                    <div class="legend-item"><span class="legend-color" style="background-color: orange;"></span>SMPUH (EXECUTADO)</div>
                    <div class="legend-item"><span class="legend-color" style="background-color: black; opacity: 0.5; background-image: linear-gradient(to right, black 50%, transparent 50%); background-size: 5px 2px;"></span>ESTUDO</div>
                    <div class="legend-item"><span class="legend-color" style="background-color: brown; opacity: 0.5;"></span>ANÁLISE</div>
                    <div class="legend-item"><span class="legend-color" style="background-color: purple; opacity: 0.6; background-image: linear-gradient(to right, purple 50%, transparent 50%); background-size: 5px 2px;"></span>PRÓXIMO (PAV)</div>
                    <div class="legend-item"><span class="legend-color" style="background-color: cyan; opacity: 0.5;"></span>PRÓXIMO (RECAPE)</div>
                ;
                
                // Evento para mostrar/esconder a legenda
                toggleButton.addEventListener('click', function() {
                    legendContent.style.display = legendContent.style.display === "none" ? "block" : "none";
                });
                
                return div;
            };
            
            legendControl.addTo(map);
        }

        // Função para inicializar o mapa
        function initializeMap() {
            // Coordenadas iniciais e zoom do mapa
            var initialCoordinates = [-21.2076, -50.4401];
            var initialZoom = 13;

            // Criando os layers de mapa base (OpenStreetMap e Satélite)
            var osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 25,
                attribution: 'Map data © <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
            });

            var cartoDBPositron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                maxZoom: 20,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
            });

            var cartoDBDarkMatter = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                maxZoom: 20,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
            });

            var stamenToner = L.tileLayer('https://server.arcgisonline.com/arcgis/rest/services/USA_Topo_Maps/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 20,
                attribution: 'Tiles © Esri'
            });

            var satelliteLayer = L.tileLayer('https://server.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 19,
                attribution: 'Tiles © Esri'
            });

            var esriTopographic = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 20,
                attribution: 'Tiles © Esri & OpenStreetMap contributors'
            });

            var arcgisDark1 = L.tileLayer('https://server.arcgisonline.com/arcgis/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 35,
                attribution: 'Tiles © Esri'
            });

            var estradas = L.tileLayer('https://server.arcgisonline.com/arcgis/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 35,
                attribution: 'Tiles © Esri'
            });

            var map = L.map('map', {
                center: initialCoordinates,
                zoom: initialZoom,
                layers: [cartoDBPositron] // Camada padrão
            });

            // Adicionar controle de legenda
            addLegendControl(map);

            // Controle para alternar as camadas de mapa, no canto inferior direito
            var baseLayers = {
                "OpenStreetMap": osmLayer,
                "Satélite": satelliteLayer,
                "Topografia": esriTopographic,
                "Carto": cartoDBPositron,
                "Escuro": cartoDBDarkMatter,
                "Estradas": estradas
            };

            L.control.layers(baseLayers, null, { position: 'bottomright' }).addTo(map);

            // URL do Google Sheets exportado como CSV
            var csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTERpcQ5NONP3R8TGHTbZ04Ckq9Bj31BCQv4SH1eXs_q1v9z-nocOi2jOJEvgE0gVBJ38rxM6KLFRNH/pub?output=csv";

            // Variáveis globais
            var allPolylines = []; // Armazena todas as polilinhas
            var allData = []; // Dados do CSV

            // Variáveis para o sistema de snap
            var snapMarker = L.marker([0, 0], {
                icon: L.divIcon({
                    className: 'snap-point',
                    iconSize: [12, 12]
                }),
                interactive: false
            }).addTo(map);
            snapMarker.setOpacity(0);
            
            var snapDistance = 20; // pixels
            var snapEnabled = true;
            var allVertices = []; // Armazenará todos os vértices das polilinhas existentes

            // Função para extrair todos os vértices das polilinhas existentes
            function updateAllVertices() {
                allVertices = [];
                allPolylines.forEach(polyline => {
                    var latlngs = polyline.getLatLngs();
                    latlngs.forEach(latlng => {
                        if (latlng.lat && latlng.lng) {
                            allVertices.push(latlng);
                        } else if (Array.isArray(latlng)) {
                            // Para polilinhas com múltiplas partes
                            latlng.forEach(subLatlng => {
                                allVertices.push(subLatlng);
                            });
                        }
                    });
                });
            }

            // Função para encontrar o vértice mais próximo do ponto do mouse
            function findClosestVertex(latlng) {
                if (!snapEnabled || allVertices.length === 0) return null;
                
                var closest = null;
                var minDistance = Infinity;
                
                allVertices.forEach(vertex => {
                    var distance = map.distance(latlng, vertex);
                    var pixelDistance = map.latLngToContainerPoint(latlng)
                        .distanceTo(map.latLngToContainerPoint(vertex));
                    
                    if (pixelDistance < snapDistance && distance < minDistance) {
                        minDistance = distance;
                        closest = vertex;
                    }
                });
                
                return closest;
            }

            // Função para definir o estilo da polilinha com base no STATUS
            function getStyleByStatus(status, tipo) {
                switch (status.toUpperCase()) {
                    case "EXECUTADA":
                        return { color: 'green', weight: 7, opacity: 0.5 };
                    case "AGUARDANDO":
                        return { color: 'red', weight: 7, opacity: 0.5 };
                    case "FUTURO":
                        return { color: 'blue', weight: 7, opacity: 0.5 };
                    case "SMPUH":
                        return { color: 'orange', weight: 4, opacity: 0.3 };
                    case "CANCELADO":
                        return { color: 'grey', weight: 4, opacity: 0.1 };
                    case "ESTUDO":
                        return { color: 'black', weight: 7, opacity: 0.5, dashArray: "5, 5" };
                    case "ANÁLISE":
                        if(tipo === 'PAVIMENTAÇÃO'){
                            return { color: 'brown', weight: 7, opacity: 0.6, dashArray: "5, 1" };
                        } else {
                            return { color: 'brown', weight: 7, opacity: 0.5 };
                        }
                    case "PROXIMO":
                        if(tipo === 'PAVIMENTAÇÃO'){
                            return { color: 'purple', weight: 7, opacity: 0.6, dashArray: "5, 1" };
                        } else {
                            return { color: 'cyan', weight: 7, opacity: 0.5 };
                        }
                    default:
                        return { color: 'blue', weight: 7, opacity: 0.5 };
                }
            }

            // Função para calcular o comprimento da polilinha (em metros)
            function calculatePolylineLength(points) {
                var length = 0;
                for (var i = 1; i < points.length; i++) {
                    length += map.distance(points[i - 1], points[i]);
                }
                return length;
            }

            // Função para desenhar as polilinhas com base nos dados e filtros
            function drawPolylines(statusFilters = [], nameFilter = "", observacaoFilter = "", remessaFilter = "", startDate = null, endDate = null) {
                // Remove as polilinhas existentes
                allPolylines.forEach(polyline => map.removeLayer(polyline));
                allPolylines = [];

                // Filtrar os dados com base nos filtros:
                var filteredData = allData.filter(row => {
                    // Filtro por STATUS
                    var statusMatch = (statusFilters.length === 0) || statusFilters.includes((row.STATUS || "").toUpperCase());
                    
                    // Filtro por NOME
                    var nameMatch = (nameFilter === "") || (row.NOME && row.NOME.toLowerCase().includes(nameFilter.toLowerCase()));
                    
                    // Filtro por OBSERVAÇÃO
                    var observacaoMatch = (observacaoFilter === "") || (row.OBSERVAÇÃO && row.OBSERVAÇÃO.toLowerCase().includes(observacaoFilter.toLowerCase()));
                    
                    // Filtro por REMESSA (EXEC)
                    var remessaMatch = (remessaFilter === "") || (row.EXEC && row.EXEC.toLowerCase().includes(remessaFilter.toLowerCase()));
                    
                    // Filtro por DATA
                    var dateMatch = true;
                    if (startDate || endDate) {
                        const rowDate = parseDate(row.DATA);
                        console.log("Row DATA:", row.DATA, "Parsed:", rowDate);
                        
                        if (rowDate) {
                            if (startDate && rowDate < startDate) {
                                dateMatch = false;
                            }
                            if (endDate && rowDate > endDate) {
                                dateMatch = false;
                            }
                        } else {
                            // Se não conseguiu parsear a data e há filtro ativo, não mostra
                            dateMatch = !(startDate || endDate);
                            console.log("Date parse failed, dateMatch:", dateMatch);
                        }
                    }
                    
                    return statusMatch && nameMatch && observacaoMatch && remessaMatch && dateMatch;
                });

                var bounds = [];

                filteredData.forEach(row => {
                    if (row.COORDENADAS) {
                        var polylinePoints = row.COORDENADAS.split(';').map(coord => {
                            var latLng = coord.split(',');
                            return latLng.length === 2 ? [parseFloat(latLng[0]), parseFloat(latLng[1])] : null;
                        }).filter(point => point !== null);

                        if (polylinePoints.length > 0) {
                            var style = getStyleByStatus(row.STATUS || "", row.TIPO || "");
                            var polyline = L.polyline(polylinePoints, style).addTo(map);
                            allPolylines.push(polyline);

                            var length = calculatePolylineLength(polylinePoints);

                            var popupContent = 
                                <b>NOME:</b> ${row.NOME || 'Não informado'}<br>
                                <b>STATUS:</b> ${row.STATUS || 'Não informado'}<br>
                                <b>TIPO:</b> ${row.TIPO || 'Não informado'}<br>
                                <b>OBSERVAÇÃO:</b> ${row.OBS|| 'Não informado'}<br>
                                <b>DATA:</b> ${row.DATA || 'Não informado'}<br>
                                <b>REMESSA:</b> ${row.EXEC || 'Não informado'}<br>
                                <b>ID:</b> ${row.ID || 'Não informado'}<br>
                                <b>COMPRIMENTO:</b> ${(length / 1000).toFixed(2)} km;
                            polyline.bindPopup(popupContent);

                            bounds = bounds.concat(polylinePoints);
                        }
                    }
                });

                // Atualiza os vértices para o sistema de snap
                updateAllVertices();

                if (bounds.length > 0) {
                    map.fitBounds(bounds);
                }
            }

            // Função para processar o CSV e inicializar os filtros
            function processCSV(data) {
                allData = data;
                var statusValues = [...new Set(data.map(row => row.STATUS).filter(status => status))];

                var control = L.control({ position: 'topright' });
                control.onAdd = function () {
                    var div = L.DomUtil.create('div', 'leaflet-control-layers');

                    var toggleButton = L.DomUtil.create('button', 'filter-toggle-button', div);
                    toggleButton.innerText = "📌";

                    var filterContent = L.DomUtil.create('div', 'filter-content', div);

                    toggleButton.addEventListener('click', function () {
                        filterContent.style.display = filterContent.style.display === "none" ? "block" : "none";
                    });

                    // Filtro por STATUS
                    filterContent.innerHTML = '<strong>Filtrar por STATUS:</strong><br>';
                    statusValues.forEach(status => {
                        var label = L.DomUtil.create('label', '', filterContent);
                        var checkbox = L.DomUtil.create('input', '', label);
                        checkbox.type = 'checkbox';
                        checkbox.value = status.toUpperCase();
                        
                        // Inicia desmarcado se for CANCELADO ou NÃO PRECISA
                        if (status.toUpperCase() === "CANCELADO" || status.toUpperCase() === "NÃO PRECISA") {
                            checkbox.checked = false;
                        } else {
                            checkbox.checked = true;
                        }
                        
                        label.appendChild(document.createTextNode(' ' + status));

                        checkbox.addEventListener('change', function () {
                            applyFilters();
                        });
                    });
                    return div;
                };

                control.addTo(map);

// Aplicar filtro inicial (excluindo CANCELADO e NÃO PRECISA)
var initialFilters = statusValues
    .filter(status => status.toUpperCase() !== "CANCELADO" && status.toUpperCase() !== "NÃO PRECISA")
    .map(status => status.toUpperCase());

drawPolylines(initialFilters);

            }

            // Função para aplicar todos os filtros
            function applyFilters() {
                // Filtros de STATUS
                var selectedStatuses = [];
                var statusCheckboxes = document.querySelectorAll('.leaflet-control-layers .filter-content input[type="checkbox"]');
                statusCheckboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        selectedStatuses.push(checkbox.value);
                    }
                });
                
                // Filtros de NOME, OBSERVAÇÃO e REMESSA
                var nameFilter = document.getElementById('search-input').value;
                var observacaoFilter = document.getElementById('observacao-input').value;
                var remessaFilter = document.getElementById('remessa-input').value;
                
                // Filtros de DATA
                var startDateInput = document.getElementById('start-date').value;
                var endDateInput = document.getElementById('end-date').value
                
                console.log("Start date input:", startDateInput);
                console.log("End date input:", endDateInput);
                
                var startDate = startDateInput ? new Date(startDateInput) : null;
                var endDate = endDateInput ? new Date(endDateInput) : null;
                
                console.log("Parsed start date:", startDate);
                console.log("Parsed end date:", endDate);
                
                // Se endDate foi definido, ajusta para o final do dia
                if (endDate) {
                    endDate.setHours(23, 59, 59, 999);
                }
                
                drawPolylines(selectedStatuses, nameFilter, observacaoFilter, remessaFilter, startDate, endDate);
            }

            // Lógica para o controle de pesquisa (NOME, OBSERVAÇÃO e REMESSA)
            document.getElementById('toggle-extra-search').addEventListener('click', function() {
                var extraSearch = document.getElementById('extra-search');
                extraSearch.style.display = (extraSearch.style.display === "none" || extraSearch.style.display === "") ? "block" : "none";
            });

            document.getElementById('search-button').addEventListener('click', function() {
                applyFilters();
            });

            document.getElementById('clear-search').addEventListener('click', function() {
                document.getElementById('search-input').value = "";
                document.getElementById('observacao-input').value = "";
                document.getElementById('remessa-input').value = "";
                document.getElementById('start-date').value = "";
                document.getElementById('end-date').value = "";
                applyFilters();
            });

            // Processar o CSV
            document.getElementById('loading-overlay').classList.add('active');
            Papa.parse(csvUrl, {
                download: true,
                header: true,
                complete: function(results) {
                    document.getElementById('loading-overlay').classList.remove('active');
                    if (!results.data || results.errors.length > 0) {
                        alert("Erro ao processar o CSV. Verifique o arquivo.");
                        console.error("Erros no CSV:", results.errors);
                    } else {
                        processCSV(results.data);
                    }
                },
                error: function(error) {
                    document.getElementById('loading-overlay').classList.remove('active');
                    alert("Erro ao carregar o CSV: " + error.message);
                    console.error(error);
                }
            });

            // Adicionar botão de desenho de polilinha
            var drawControl = L.control({ position: 'topleft' });
            drawControl.onAdd = function () {
                var div = L.DomUtil.create('div', 'leaflet-control-layers');
                var drawButton = L.DomUtil.create('button', 'filter-toggle-button draw-toggle-button', div);
                drawButton.innerText = "✏️";
                drawButton.title = "Desenhar Polilinha";
                return div;
            };
            drawControl.addTo(map);

            // Variáveis e funções para o modo de desenho
            var drawingMode = false;
            var tempPolyline = null;
            var tempPoints = [];
            var firstClickIgnored = false; // Controla o primeiro clique

            function toggleDrawingMode() {
                drawingMode = !drawingMode;
                var drawButton = document.querySelector('.draw-toggle-button');
                
                if (drawingMode) {
                    // Ativa o modo de desenho
                    drawButton.classList.add('drawing-active');
                    tempPoints = [];
                    tempPolyline = null;
                    firstClickIgnored = false;
                    map.on('click', addPointToPolyline);
                } else {
                    // Desativa o modo de desenho
                    drawButton.classList.remove('drawing-active');
                    map.off('click', addPointToPolyline);
                    if (tempPolyline) {
                        map.removeLayer(tempPolyline);
                    }
                    if (tempPoints.length === 1) {
                        var coordinates = tempPoints.map(point => point.lat + ',' + point.lng).join(';');
                        L.popup()
                            .setContent("Coordenadas da polilinha")
                            .openOn(map);
                    }
                }
            }

            function addPointToPolyline(e) {
                if (!firstClickIgnored) {
                    firstClickIgnored = true;
                    return;
                }
                
                // Verifica se há um vértice próximo para snap
                var snappedPoint = findClosestVertex(e.latlng);
                var finalPoint = snappedPoint || e.latlng;
                
                tempPoints.push(finalPoint);
                if (tempPolyline) {
                    map.removeLayer(tempPolyline);
                }
                tempPolyline = L.polyline(tempPoints, { color: 'black', weight: 4, opacity: 0.5 }).addTo(map);
                
                var coordinates = tempPoints.map(point => point.lat + ',' + point.lng).join(';');
                document.getElementById('coordinates-output').value = coordinates;
            }

            // Atualiza a posição do marcador de snap durante o movimento do mouse
            map.on('mousemove', function(e) {
                if (!drawingMode || !snapEnabled) {
                    snapMarker.setOpacity(0);
                    return;
                }
                
                var closestVertex = findClosestVertex(e.latlng);
                if (closestVertex) {
                    snapMarker.setLatLng(closestVertex);
                    snapMarker.setOpacity(1);
                } else {
                    snapMarker.setOpacity(0);
                }
            });

            // Associar o botão de desenho à função de alternar o modo de desenho
            document.querySelector('.leaflet-control-layers .draw-toggle-button').addEventListener('click', toggleDrawingMode);

            // Função para copiar as coordenadas para a área de transferência
            function copyCoordinates() {
                var textArea = document.getElementById('coordinates-output');
                textArea.select();
                document.execCommand("copy");
            }
            window.copyCoordinates = copyCoordinates;
        }
    </script>
</body>
</html>
